<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>梦璃酱</title><description>YumeYuka Blog of Dreams</description><link>https://yumeyuka.plus/</link><language>zh_CN</language><item><title>从 EdgeOne 开始的奇妙旅程——加速你的 GitHub 图床</title><link>https://yumeyuka.plus/posts/edgeone-gh/</link><guid isPermaLink="true">https://yumeyuka.plus/posts/edgeone-gh/</guid><pubDate>Tue, 23 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;使用项目&lt;/h2&gt;
&lt;p&gt;实现开始之前，需要准备一个域名，备案最好，不备案建议使用cf 优选，不要用eo 了&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;cmliu/CF-Workers-Raw&quot;}&lt;/p&gt;
&lt;p&gt;这个项目一开始是在 &lt;code&gt;Cloudflare Work&lt;/code&gt; 部署的后来 &lt;code&gt;Edgeone pages&lt;/code&gt; 出来之后，有人开了个 issue 就支持了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/cmliu/CF-Workers-Raw/issues/9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-21-40.webp&quot; alt=&quot;image-20250923214032532&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;延迟数据&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-21-48.webp&quot; alt=&quot;image-20250923214838483&quot; /&gt;&lt;/p&gt;
&lt;p&gt;EO Pages 和 cdn 节点不一样，pages 最多给分配30个节点，由于直接这样用国内的cdn节点直接去代理 GitHub 文件肯定是不行的&lt;/p&gt;
&lt;p&gt;平时绝大多数地方直接访问大概率也是被墙的 &lt;code&gt;GFW&lt;/code&gt; 发力了，想要做代理，那就需要去用到 EO 给分配的香港节点，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;EO 刚出来的时候确实是白月光，即使没备案直接 优选 香港节点，延迟优化很错，差不多相当于是全绿了&lt;/p&gt;
&lt;p&gt;但是后面 8 月 初就开始砍了，现在优选 香港节点的话大概率会直接得到 &lt;code&gt;418&lt;/code&gt; 状态码，这样开来还不让直接优选 cf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先把这项目自己 Fork 一份 ，用 CF 代理也行 用 EO pages 也行,没备案建议使用 cf work 优选,&lt;/p&gt;
&lt;p&gt;::github{repo=&quot;cmliu/CF-Workers-Raw&quot;}&lt;/p&gt;
&lt;p&gt;然后再 cf work 或者 eo pages 直接直接链接账户 导入 &lt;code&gt;Edgeone&lt;/code&gt; 分支, cf 是默认的 &lt;code&gt;mian&lt;/code&gt; 分支 ,部署之后需要绑定
自定义的域名访问，，然后有以下3种方案&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;cf work + eo cdn&lt;/th&gt;
&lt;th&gt;体验最好&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cf work +　cf 优选&lt;/td&gt;
&lt;td&gt;推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eo pages +　eo 优选&lt;/td&gt;
&lt;td&gt;推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以第一种为例，运行work 部署运行之后然后需要在 work 绑定自定义域名，然后在 EO 的站点添加 cdn 配置，然后解析 cname ,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;如果 eo 是NS 接入的话就需要2个域名，一个在 cf work 一个用于 eo cdn 分发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-22-10.webp&quot; alt=&quot;image-20250923221008843&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 SSL 证书申请选择： 建议使用 腾讯云 申请 SSL 的证书，至于为什么因为后面优选 IP 需要用到 ，优选 IP 原有的 cname 记录会失效，然后
A 记录直接解析到优选 IP ，如果选择申请免费的证书，cname 失效之后会导致 续签失败，建议直接使用 腾讯云申请的 SSL 证书，选择
DNS验证然后不用删记录，直接等它自己续费就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-22-16.webp&quot; alt=&quot;image-20250923221632239&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后优选 IP ，直接优选 香港 IP ，具体 IP段去看其他文档或者其他人写的 blog&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    43.174.150.199
    43.174.150.119
    43.174.151.16
    43.174.151.120
    43.174.151.58
    43.174.150.6
    43.174.150.123
    43.174.151.214
    43.174.151.241
    43.174.151.165
    43.174.150.111
    43.174.151.2
    43.174.151.243
    43.174.150.132
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Github 配置&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;setting&lt;/code&gt; 生成一个 token 然后 使用 &lt;code&gt;piclist picgo&lt;/code&gt; 等其他的图床工具，配合 &lt;code&gt;Typora&lt;/code&gt; 写，确实很不错的&lt;/p&gt;
&lt;p&gt;注意 自定义域名部分, 拼接部分需要注意，相对于使用 eo pages 然后去链接 &lt;code&gt;GitHub&lt;/code&gt; 储存库然后每次上传都要 build 好很多&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-22-27.webp&quot; alt=&quot;image-20250923222700864&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;图片示例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-22-30.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>网易云降噪小魔法</title><link>https://yumeyuka.plus/posts/cloudpress/</link><guid isPermaLink="true">https://yumeyuka.plus/posts/cloudpress/</guid><description>可恶的网易云！明明只是想安静听歌，结果还要跟压制模块斗智斗勇(&gt;_&lt;)</description><pubDate>Mon, 07 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;网易云压制模块&lt;/h1&gt;
&lt;p&gt;本来一个月前就该发出来的，最近突然想起来还没发出来，
这一版相比之前没什么区别，还是建议更新到此版本，上版是 &lt;code&gt;CPP&lt;/code&gt; 写的，这一版用 &lt;code&gt;kotlin native&lt;/code&gt; 重写了,逻辑上没有变化，还是监听前台进程然后kill
掉多余的不需要的服务&lt;/p&gt;
&lt;p&gt;国内的毒瘤 APP 都太多了，点名网易云最为代表，听歌 APP 什么都有，本来性能就很差，还要在后台留一堆不需要的服务，太坏了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;非常 素晴らしい&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;编写语言&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;kotlin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;压制效果&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;中等，不知道网易云太坏了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bug&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;几乎没有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;评价&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;能用，但不多，治标不治本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;下载链接&lt;/strong&gt;：&lt;a href=&quot;https://yumeyuka.plus/zip/Yume-Yunyun.zip&quot;&gt;Yume-Yunyun.zip&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;示例伪代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;head.hpp&quot;

main() 
    Logger::Create(INFO, &quot;/sdcard/Android/Yume-Yunyun/server.log&quot;)
    start_thread(clearLog).detach()

    cloudMusicPackage = &quot;com.netease.cloudmusic&quot;
    playProcess = &quot;com.netease.cloudmusic:play&quot;
    CHECK_INTERVAL = 30

    Logger::Info(&quot;服务已启动，监控网易云音乐进程&quot;)

    while (true)
        if (!isAppRunning(cloudMusicPackage))
            sleep(CHECK_INTERVAL)
            continue

        currentAppName = getCurrentAppName()
        Logger::Info(&quot;当前前台应用: &quot; + currentAppName)

        if (currentAppName 不包含 cloudMusicPackage)
            processes = getAppProcessesAndPIDs(cloudMusicPackage)
            Logger::Info(&quot;网易云不在前台，找到进程数：&quot; + processes.size())

            if (processes 为空)
                Logger::Info(&quot;没有找到进程，等待下一次检查&quot;)
            else
                for each process in processes
                    if (process.name 包含 playProcess)
                        Logger::Info(&quot;保留播放进程: &quot; + process.name + &quot;, PID: &quot; + process.pid)
                    else
                        Logger::Info(&quot;终止进程: &quot; + process.name + &quot;, PID: &quot; + process.pid)
                        killProcess(process.pid)
        else
            Logger::Info(&quot;网易云音乐在前台，不做操作&quot;)
        
        sleep(CHECK_INTERVAL)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;题外话&lt;/h2&gt;
&lt;p&gt;Kt Native 编译出来的目标 ELF 大小上和 C++ 差距不大,但是运行时内存占用可谓是天差地别 ,差了近 10 倍 的内存占用 ,当然 Kt
Native 会自动 GC 回收内存, 以本模块为例,大概 刚运行时为 50M 一段时间之后 GC 会到25M ,差不多回收了 1/2 但是和 C++
编译出来还是差距很大&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;Kt Native MacOS 和 IOS 为大致为第一梯队 , Linux 差不多为第二梯队, Android 和Windows差不多就是第三梯队了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.yumeyuka.plus/Keira-Yuki/picture/refs/heads/Yume/2025/23-21-09.webp&quot; alt=&quot;image-20250923210928868&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>单片机的魔法入门课</title><link>https://yumeyuka.plus/posts/microcontroller/</link><guid isPermaLink="true">https://yumeyuka.plus/posts/microcontroller/</guid><description>和单片机酱一起启程～从环境搭建到数码管显示，解锁动态扫描的小秘密♪</description><pubDate>Wed, 13 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;数码管显示的一些使用的操作&lt;/h3&gt;
&lt;p&gt;晶体数码管按公共端极性可分为共阴极和共阳极两种。由于每次只能点亮一位，要实现多位同时显示，就必须配合锁存器以及段选、位选电路，采用动态扫描的方式。动态扫描利用人眼的视觉滞留效应，通过高速轮询各位并依次点亮，让多位数码管看起来像是同时显示。但如果刷新速度过快，切换瞬间会产生残影；速度过慢，又会出现闪烁。因此，在位选与段选切换处需加入适当的消抖延时，既能消除重影，又保证显示稳定。无论共阴极还是共阳极，原理相同，都是通过合理控制每个位的点亮时间和刷新频率，实现清晰、流畅的动态显示。&lt;/p&gt;
&lt;h3&gt;环境配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载安装Clion&lt;/li&gt;
&lt;li&gt;安装 PlatformIO 插件&lt;/li&gt;
&lt;li&gt;在clion中新建一个项目，根据提示配置环境&lt;/li&gt;
&lt;li&gt;编写一个简单的代码测试环境是否配置成功&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;mcs51/8052.h&amp;gt;

void main()

{
    while(1)
    {
        P1 = 0xfe;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;环境配置文件(以stc89c52rc为例)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[env:STC89C52RC]
platform = intel_mcs51
board = STC89C52RC

lib_deps = C:\Users\Night\.platformio\packages\toolchain-sdcc\include 
// 这里配置环境安装路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数码管位选和段选&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 选择位
void SelectBit(unsigned char pos) {
 Init74HC138(6); // Open COM end
 P0 = 0x00;      // Turn off all segments
 DelaySMG(10);   // Short delay to eliminate shadow
 P0 = (0x01 &amp;lt;&amp;lt; pos);
}

// 选择段
void SelectSegment(unsigned char value) {
 Init74HC138(7); // 打开段选端
 P0 = value;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;74HC573锁存器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;void int74h573(unsigned int n) {
  switch (n) {
  case 4:
    P2 = (P2 &amp;amp; 0x1f) | 0x80;
    break;
  case 5:
    P2 = (P2 &amp;amp; 0x1f) | 0xa0;
    break;
  case 6:
    P2 = (P2 &amp;amp; 0x1f) | 0xc0;
    break;
  case 7:
    P2 = (P2 &amp;amp; 0x1f) | 0xe0;
    break;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;动态显示数码管&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 动态显示数码管
void DisplaySMG_Dynamic() {
  SelectBit(0);
  SelectSegment(SMG_NoDot[hour / 10]);
  DelaySMG(500);

  SelectBit(1);
  SelectSegment(SMG_NoDot[hour % 10]);
  DelaySMG(500);

  SelectBit(2);
  SelectSegment(SMG_NoDot[16]);
  DelaySMG(500);

  SelectBit(3);
  SelectSegment(SMG_NoDot[minute / 10]);
  DelaySMG(500);

  SelectBit(4);
  SelectSegment(SMG_NoDot[minute % 10]);
  DelaySMG(500);

  SelectBit(5);
  SelectSegment(SMG_NoDot[16]);
  DelaySMG(500);

  SelectBit(6);
  SelectSegment(SMG_NoDot[second / 10]);
  DelaySMG(500);

  SelectBit(7);
  SelectSegment(SMG_NoDot[second % 10]);
  DelaySMG(500);
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>DNS的秘密日记～从hosts开始的物语（下）</title><link>https://yumeyuka.plus/posts/hosts-dns-part2/</link><guid isPermaLink="true">https://yumeyuka.plus/posts/hosts-dns-part2/</guid><description>从最初的HOSTS.TXT到如今庞大的DNS体系，这篇小日记记录了域名解析的发展历程，带你了解DNS如何替代hosts、层级化域名空间的形成，以及DNSSEC、根服务器和国际化域名的出现☆ </description><pubDate>Thu, 26 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;域名解析系统发展史&lt;/h2&gt;
&lt;h3&gt;早期互联网和主机文件（HOSTS.TXT）&lt;/h3&gt;
&lt;p&gt;在DNS出现之前，互联网的域名解析依赖于一个中心化的文件：HOSTS.TXT。这个文件由斯坦福研究所（SRI）的Network Information Center (NIC) 维护，列出了每个域名对应的IP地址。每台计算机必须手动下载并更新这个文件才能进行域名解析。&lt;/p&gt;
&lt;p&gt;随着互联网的发展和联网设备数量的增加，这种方法逐渐显得低效和不可扩展。尤其是随着互联网向全球化发展，HOSTS.TXT文件变得过大且更新频繁，无法满足需求。&lt;/p&gt;
&lt;p&gt;为了应对早期域名解析方案的局限性，Paul Mockapetris在1983年提出了DNS系统的概念并编写了最初的DNS协议规范（RFC 882 和 RFC 883，后被更完善的RFC 1034 和 RFC 1035替代）。DNS的核心思想是通过一个分布式、层级化的系统来进行域名解析，解决了HOSTS.TXT文件集中管理带来的扩展性问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img.nightrainmilkyway.cn/img/v2-ed152d58f9c04e9a19e4a053c30dae38_1440w.png&quot;&gt;&lt;img src=&quot;https://img.nightrainmilkyway.cn/img/v2-ed152d58f9c04e9a19e4a053c30dae38_1440w.png&quot; alt=&quot;v2-ed152d58f9c04e9a19e4a053c30dae38_1440w.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;域名空间的扩展 (1980年代后期)&lt;/h3&gt;
&lt;p&gt;随着DNS的推出，顶级域名（TLDs）逐渐被引入，并按照不同的用途分类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;/p&gt;
&lt;p&gt;通用顶级域名（gTLDs）：如 .com（商业组织）、.org（非营利组织）、.edu（教育机构）、.net（网络相关）。&lt;/p&gt;
&lt;p&gt;国家顶级域名（ccTLDs）：如 .cn（中国）、.uk（英国）等，专门为各国或地区保留。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;域名系统采用层次化结构，其中每一级用“.”符号分隔。根据域名的层级关系，域名可以分为顶级域名（TLD）、二级域名、三级域名等多级域名。下面详细介绍域名的层级划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级域名 (TLD)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顶级域名是域名结构的最高层级，位于域名最右边。TLD通常由ICANN（互联网名称与数字地址分配机构）管理。顶级域名分为以下几类：&lt;/p&gt;
&lt;p&gt;通用顶级域名 (gTLDs)： 这些是最常见的顶级域名，用于特定用途或类型的网站：&lt;/p&gt;
&lt;p&gt;.com：最初为商业机构设计，现在广泛用于各种网站。&lt;/p&gt;
&lt;p&gt;.org：用于非营利组织，但也被许多其他组织采用。&lt;/p&gt;
&lt;p&gt;.net：最初为网络服务提供商设计，现在广泛使用。&lt;/p&gt;
&lt;p&gt;.edu：用于美国的教育机构。&lt;/p&gt;
&lt;p&gt;.gov：用于美国政府部门。&lt;/p&gt;
&lt;p&gt;.mil：用于美国军事机构。
国家顶级域名 (ccTLDs)： 每个国家或地区都有专门的顶级域名，以两个字母代码表示。常见的 ccTLD 包括：&lt;/p&gt;
&lt;p&gt;.cn：中国&lt;/p&gt;
&lt;p&gt;.uk：英国&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二级域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二级域名是位于顶级域名之下的下一级域名，通常是组织或企业的名字，用来标识特定的组织、公司或个人。例如：&lt;/p&gt;
&lt;p&gt;在www.example.com中，example是二级域名。&lt;/p&gt;
&lt;p&gt;在www.google.cn中，google是二级域名。&lt;/p&gt;
&lt;p&gt;二级域名通常由域名持有者根据其需求自定义，它们可以是企业名称、品牌、服务类型或其他识别符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三级域名及多级域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三级域名是位于二级域名之下的域名。三级及多级域名通常用于区分子站点、服务或功能。例如：&lt;/p&gt;
&lt;p&gt;www：是一个常见的三级域名，表示网页服务（World Wide Web
mail.google.com：mail是三级域名，表示谷歌的邮件服务（Gmail）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.nightrainmilkyway.cn/img/v2-19057161c905080d05210161b0772ae1_1440w.webp&quot; alt=&quot;v2-19057161c905080d05210161b0772ae1_1440w.webp&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;DNSSEC 的引入 (1990年代末 - 2000年代)&lt;/h3&gt;
&lt;p&gt;虽然DNS系统设计得非常灵活，但随着互联网的快速发展，安全问题逐渐显现。DNS系统缺乏对解析数据真实性的验证机制，容易受到攻击，如DNS欺骗（DNS Spoofing）和中间人攻击。&lt;/p&gt;
&lt;p&gt;为了解决这些问题，DNSSEC（Domain Name System Security Extensions，域名系统安全扩展）在1990年代末提出，并在2000年代开始逐渐推广。DNSSEC通过对DNS记录进行数字签名，确保解析结果的真实性和完整性，防止恶意篡改。&lt;/p&gt;
&lt;h3&gt;根域名服务器的全球部署&lt;/h3&gt;
&lt;p&gt;DNS的根域名服务器是DNS体系中最顶层的服务器，最初只在美国部署。但为了提高DNS的可靠性和性能，根域名服务器逐渐被扩展到全球范围内。目前有13组根域名服务器，由不同的组织和公司管理，这些服务器分布在多个国家和地区，通过Anycast技术保证全球用户能够快速访问。
&lt;img src=&quot;https://img.nightrainmilkyway.cn/img/%E4%B8%8B%E8%BD%BD%20(1).jpeg&quot; alt=&quot;下载 (1).jpeg&quot; /&gt;&lt;/p&gt;
&lt;h4&gt;为什么DNS根服务器只能有13台？&lt;/h4&gt;
&lt;p&gt;DNS协议的限制：DNS系统最早的设计是在1980年代，那个时候的互联网协议（如IPv4）和硬件性能都相对有限。DNS查询时使用的是UDP数据包，最大包大小为512字节。在这个限制下，返回给客户端的DNS查询结果列表必须足够小，以免超出512字节的限制&lt;/p&gt;
&lt;p&gt;根服务器IP地址的数量：在DNS系统中，客户端查询根域名时需要获取根域名服务器的IP地址列表。DNS解析器通过“根提示文件”（root hints file）来获取所有根服务器的IP地址信息。13个根服务器的IP地址列表恰好能适应这个512字节的限制。&lt;/p&gt;
&lt;h3&gt;国际化域名 (IDN) 的引入&lt;/h3&gt;
&lt;p&gt;随着全球互联网用户数量的增长，尤其是非英语国家用户的增加，使用仅支持ASCII字符的域名系统逐渐显得不足。为了支持更多的语言字符，国际化域名（IDN）在2000年代引入，允许使用非拉丁字符的域名（如中文、阿拉伯文、韩文等）&lt;/p&gt;
</content:encoded></item><item><title>DNS的秘密日记～从hosts开始的物语（上）</title><link>https://yumeyuka.plus/posts/hosts_dns_part1/</link><guid isPermaLink="true">https://yumeyuka.plus/posts/hosts_dns_part1/</guid><description>从hosts酱到DNS君的故事～带你认识域名解析的基础原理，理解为什么修改hosts能直连，以及DNS污染和劫持这些小捣蛋鬼的秘密♪</description><pubDate>Mon, 23 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;hosts 是什么？&lt;/h2&gt;
&lt;p&gt;在很早很早以前，域名解析系统还没有建立起来，全球的网络主机还很少的时候，IP 地址的映射主要靠的就是各主机里的 hosts 文件来实现，那时候的 hosts 文件保存着互联网上所有主机地址的映射。而 hosts 文件的更新是由一个专门来维护 hosts 文件的站点来实现。也就是说那时根本就不需要也没有 DNS 服务器这东西，用自己主机上的 hosts 文件就可以找到对方的 IP 地址然后建立连接了&lt;/p&gt;
&lt;p&gt;但是后来随着互联网的规模不断扩大，&lt;code&gt;hosts&lt;/code&gt;文件的维护也越来越困难，毕竟全球的网络主机都需要通过这个负责维护 hosts 更新站点来更新，hosts 所存放的解析记录数量级不断增加，单单只是检索就要花不少时间 &lt;a&gt;修改hosts文件理解DNS - （下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我们打开这个&lt;code&gt;hosts&lt;/code&gt;文件之后可以发现里面有一下内容&lt;/p&gt;
&lt;p&gt;Windows 目录是: &lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux 目录是: &lt;code&gt;/etc/hosts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
20.205.243.166　　github.com
61.91.161.217	www.google.com
61.91.161.217	google.com
61.91.161.217	gcr.io
61.91.161.217	www.gcr.io
61.91.161.217	com.google
61.91.161.217	admin.google.com
61.91.161.217	accounts.google.com
61.91.161.217	accounts.google.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到第一行就是我们所熟悉的&lt;code&gt;127.0.0.1　　localhost&lt;/code&gt;，就是在hosts中定义的&lt;/p&gt;
&lt;p&gt;可以看第 5 行前面是 IP 后面是域名一一对应，是不是突然就明白了这个&lt;code&gt;hosts&lt;/code&gt;文件的作用&lt;/p&gt;
&lt;h2&gt;DNS 是什么&lt;/h2&gt;
&lt;p&gt;DNS（Domain Name System，域名系统），将人类可读的域名（例如 www.example.com）转换为机器用于相互通信的IP地址（例如 192.0.2.1 或 2001:db8::1）的一种分布式数据库。打个比方来说，DNS就像一个电话簿，IP相当于电话号码，域名相当于联系人&lt;/p&gt;
&lt;p&gt;这几条可以看出一个 IP 地址可以同时对应多个域名，这也就是为什么平时在地址栏上输入 google.com或www.google.com都可以访问 google 了。而https://是浏览器自动帮你加上去的，平时我们访问不了 google 的原因是，google 的域名 在本机转化为 IP 地址后经过中国大陆的防火长城，被防火长城检测到与黑名单内的关键词匹配（如：Google、Facebook、twitter等都在黑名单内），然后就会伪装成目标域名的解析服务器返回虚假的查询结果。关键的是通常的域名查询没有任何认证机制，而且域名的查询一般是基于无连接不可靠的 UDP 协议，所以浏览器只能接受最先到达的格式正确结果，并把之后的所有结果丢弃。所以这也就访问不了啦，这种情况就是所谓的 DNS 缓存污染，也称为 DNS 缓存投毒（这个真形象…）&lt;a href=&quot;https://famousczm.github.io/2017/05/07/%E4%BB%8E%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B8%AD%E7%90%86%E8%A7%A3DNS%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;参考文献-从修改hosts文件科学上网中理解DNS（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个域名背后可以有多个I地址。当域名解析服务器在解析域名记录的“值”中包含多个IP地址时，LDNS会返回所有IP地址，但返回I地址的顺序是随机的。浏览器默认选取第一个返回的 IP地址作为解析结果，其解析流程如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网站访问者通过浏览器向Local DNS（简称LDNS）发送解析请求。&lt;/li&gt;
&lt;li&gt;LDNS将解析请求逐级转发（递归）至权威DNS。&lt;/li&gt;
&lt;li&gt;权威DNS在收到解析请求后，将所有I地址以随机顺序返回LDNS。&lt;/li&gt;
&lt;li&gt;LDNS将所有IP地址返回浏览器。&lt;/li&gt;
&lt;li&gt;网站访问者的浏览器随机访问其中一个I地址，通常（不是绝对）选取第一个返回的IP地址。在没有做反向代理的情况下，如果返回的IP地址有多个，那么访问到这些IP地址的机会一般是均等的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img.nightrainmilkyway.cn/img/v2-c3392cab45f8241c0369ec6457000df8_1440w.webp&quot; alt=&quot;v2-c3392cab45f8241c0369ec6457000df8_1440w.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在DNS解析的描述过程中，浏览器首先通过本地的DNS服务（LDNS）发送第一个
解析请求，然后由LDNS返回IP地址，访问对应的服务器所提供的互联网服务。
这样就带来了一个问题：如果LDNS返回的不是公网的域名解析服务解析出的IP地址，
而是经过本地篡改的呢？&lt;/p&gt;
&lt;h3&gt;域名篡改&lt;/h3&gt;
&lt;p&gt;域名会被篡改吗？或域名解析服务器在解析域名后返回的IP地址会被篡改吗？
在回答上述问题前，我们先查看Linux系统中有关DNS的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt;：记录hostname对应的IP地址
&lt;code&gt;/etc/resolv.conf&lt;/code&gt;：设置DNS服务器的IP地址
&lt;code&gt;/etc/host.conf&lt;/code&gt;：指定域名解析的顺序，是先从hosts 解析还是先从DNS解析&lt;/p&gt;
&lt;p&gt;LDNS 优先解析hosts 文件（Windows 路径是&lt;code&gt;C：\Windows\System32\driversletclhosts&lt;/code&gt;）,在hosts文件中，改变域名指向的I地址，我们将不会访问到原来的公网主机。示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxido ~]# ping linuxido.com({})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;→在修改前，对城名执行ping命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PING linuxido.com (123.56.94.254) 56(84) bytes of data.
64 bytes from 123.56.94.254 (123.56.94.254): icmp _seq=1 ttl=53 time=25.6 ms
[root@linuxido ~l# dig +short linuxido.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;→使用dig命令解析域名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123.56.94.254
##→修改域名对应的IP地址
[root@linuxido~]# echo &apos;120.120.120.120 linuxido.com&apos; &amp;gt;&amp;gt; /etc/hosts

[root@linuxido~]# ping linuxido.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;→修改后，再对域名执行ping命今&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PING linuxido.com (120.120.120.120) 56(84) bytes of data.
并→可以看到ping命令失败，无法ping通120.120.120.120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;→使用host命令解析城名，可以看到依然是公网IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxido~l# host linuxido.com
linuxido.com has address 123.56.94.254[root@linuxido ~]# nslookup linuxido.com Server:
Address:
8.8.8.8
8.8.8.8#53
Non-authoritative answer:
Name:
linuxido.com Address: 123.56.94.254
[root@linuxido ~]# dig linuxido.com
linuxido.com.
599
IN
A
123.56.94.254
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##一修改hosts 文件后，dig命令解析的城名依然是公网IP地址。找寻A的记录，它是不经过LDNS
iSERVER:8.8.8.8#53（8.8.8.8)
##→本机的DNS地址设置为8.8.8.8，DNS的默认端口是53
如果没有修改 hosts 文件，在什么情况下可能出现DNS返回错误的IP 地址呢？域名劫持是最可能出现的情况。域名劫持就是通过攻击或伪造域名解析服务器的方式，把目标网站域名解析到错误的 I地址，从而使用户访问一些非法、恶意网站。因此，我们需要使用域名解工具查看访问域名是都真正对应IP地址&lt;/p&gt;
&lt;h3&gt;DNS污染&lt;/h3&gt;
&lt;p&gt;网域服务器缓存污染（英语：DNS cache pollution）、DNS污染或DNS劫持，是一种破坏域名系统查询解析的行为。[1]通常有计算机程序自动执行DNS劫持攻击导致DNS服务器缓存了错误记录的现象。而域名服务器缓存投毒（DNS cache poisoning）和DNS缓存投毒指由计算机程序执行的DNS劫持攻击。污染一词可能取自域名系统域名解析之特性，若递归DNS解析器查询上游时收到错误回复，所有下游也会受影响 &lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93&quot;&gt;参考文献（3）-域名服务器缓存污染&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;hosts是如何实现科学上网的&lt;/h2&gt;
&lt;p&gt;这里以GitHub为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;20.205.243.166　　github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GitHub站点毕竟在国外，当dns请求时返回最快的那一个IP，但是想要访问就肯定要走大陆宽带，防火长城就会返回一个假的结果，那么hosts为什么能直接连上GitHub呢，这里就不得不提及域名解析的优先级了，&lt;code&gt;hosts &amp;gt; DNS&lt;/code&gt;，在DNS域名解析系统建立起来之后hosts被弃用，但仍然保留在Linux，Windows系统内，而且优先级一般大于dns解析结果，从而能够建立连接&lt;/p&gt;
&lt;p&gt;当然，如果想流畅的访问GitHub单单只是修改hosts效果并不明显，可以搭配&lt;a href=&quot;https://github.com/WangGithubUser/FastGitHub&quot;&gt;FastGithub&lt;/a&gt;合法的工具访问
&lt;img src=&quot;https://img.nightrainmilkyway.cn/img/20.205.243.166.png&quot; alt=&quot;20.205.243.166.png&quot; /&gt;&lt;/p&gt;
</content:encoded></item></channel></rss>